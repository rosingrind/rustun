use crate::message::StunAttributes;
use crate::StunAgentError;
use std::collections::HashSet;
use stun_rs::attributes::stun::{MessageIntegrity, MessageIntegritySha256, UserName};
use stun_rs::error::{StunDecodeError, StunEncodeError};
use stun_rs::{get_input_text, HMACKey, MessageClass, StunAttribute, StunMessage, TransactionId};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AuthValidationError {
    Discarded,
    ProtectionViolated,
}

impl From<AuthValidationError> for StunAgentError {
    fn from(err: AuthValidationError) -> StunAgentError {
        match err {
            AuthValidationError::Discarded => StunAgentError::Discarded,
            AuthValidationError::ProtectionViolated => StunAgentError::ProtectionViolated,
        }
    }
}

impl From<StunEncodeError> for StunAgentError {
    fn from(err: StunEncodeError) -> StunAgentError {
        StunAgentError::EncodeError(err)
    }
}

impl From<StunDecodeError> for StunAgentError {
    fn from(err: StunDecodeError) -> StunAgentError {
        StunAgentError::DecodeError(err)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Integrity {
    MessageIntegrity,
    MessageIntegritySha256,
}
/*
struct ShortTermAuthServer {
    remote_key: Option<HMACKey>,
}

impl ShortTermAuthServer {
    fn discard_message(&self, msg: &StunMessage) -> AuthValidation {
        if msg.class() == MessageClass::Request {
            // If the message is a request, the server MUST reject the request
            // with an error response.  This response MUST use an error code
            // of 400 (Bad Request).
            // TODO: Send 400 BadRequest
            todo!("Send 400 BadRequest");
        }
        // If the message is an indication, the agent MUST silently discard the indication.
        return AuthValidation::Discarded;
    }

    /// 9.1.3 Receiving a Request or Indication
    fn process_request_or_indication_1(
        &mut self,
        raw_buffer: &[u8],
        msg: &StunMessage,
    ) -> Result<(), AuthValidation> {
        let mut integrity = None;
        let mut integrity_sha256 = None;
        let mut user_name = None;

        for attr in msg.attributes() {
            if user_name.is_none() && attr.is_user_name() {
                user_name = Some(attr);
            }
            if integrity.is_none() && attr.is_message_integrity() {
                integrity = Some(attr);
            }
            if integrity_sha256.is_none() && attr.is_message_integrity_sha256() {
                integrity_sha256 = Some(attr);
            }
        }

        let integrity = integrity_sha256.or(integrity);
        if user_name.is_none() || integrity.is_none() {
            return Err(self.discard_message(msg));
        }

        todo!("Signal that we need to confirm that username is valid for this server");
    }

    fn process_request_or_indication_2(
        &mut self,
        raw_buffer: &[u8],
        attr: &StunAttribute,
        msg: &StunMessage,
    ) -> Result<(), AuthValidation> {
        if let Some(key) = &self.remote_key {
            if validate_message_integrity(attr, key, raw_buffer) {
                return Ok(());
            }
        }

        Err(self.discard_message(msg))
    }

    fn recv_message(&mut self, raw_buffer: &[u8], msg: &StunMessage) -> Result<(), AuthValidation> {
        match msg.class() {
            MessageClass::Request | MessageClass::Indication => {
                self.process_request_or_indication_1(raw_buffer, msg)
            }
            MessageClass::SuccessResponse | MessageClass::ErrorResponse => {
                Err(AuthValidation::Discarded)
            }
        }
    }

    fn prepare_response(&self, request: &mut StunMessage) {
        // Any response generated by a server to a request that
        // contains a MESSAGE-INTEGRITY-SHA256 attribute MUST include the
        // MESSAGE-INTEGRITY-SHA256 attribute, computed using the password
        // utilized to authenticate the request.  Any response generated by a
        // server to a request that contains only a MESSAGE-INTEGRITY attribute
        // MUST include the MESSAGE-INTEGRITY attribute, computed using the
        // password utilized to authenticate the request.  This means that only
        // one of these attributes can appear in a response.  The response MUST
        // NOT contain the USERNAME attribute.
        todo!("Prepare response");
    }
}
*/
pub struct ShortTermAuthClient {
    user_name: UserName,
    key: HMACKey,
    integrity: Option<Integrity>,
    is_reliable: bool,
    discarded: HashSet<TransactionId>,
}

impl ShortTermAuthClient {
    pub fn new(
        user_name: UserName,
        key: HMACKey,
        integrity: Option<Integrity>,
        is_reliable: bool,
    ) -> ShortTermAuthClient {
        Self {
            user_name,
            key,
            integrity,
            is_reliable,
            discarded: HashSet::new(),
        }
    }

    fn discard_message(&mut self, message: &StunMessage) -> AuthValidationError {
        if self.is_reliable {
            // If the request was sent over a reliable transport, the response MUST
            // be discarded, and the layer MUST immediately end the transaction and
            // signal that the integrity protection was violated.
            AuthValidationError::ProtectionViolated
        } else {
            // If the request was sent over an unreliable transport, the response
            // MUST be discarded, as if it had never been received.  This means that
            // retransmits, if applicable, will continue.  If all the responses
            // received are discarded, then instead of signaling a timeout after
            // ending the transaction, the layer MUST signal that the integrity
            // protection was violated.
            self.discarded.insert(*message.transaction_id());
            AuthValidationError::Discarded
        }
    }

    fn compute_message_integrity(
        &mut self,
        integrity: Option<&StunAttribute>,
        raw_buffer: &[u8],
        message: &StunMessage,
    ) -> Result<(), AuthValidationError> {
        if let Some(integrity) = integrity {
            // Check that the message can be authenticated
            if validate_message_integrity(integrity, &self.key, raw_buffer) {
                self.discarded.remove(message.transaction_id());
                return Ok(());
            }
        }

        // both MESSAGE-INTEGRITY and MESSAGE-INTEGRITY-SHA256 attributes are absent
        // or failed to compute integrity check, the processing depends on whether the
        // request was sent over a reliable or an unreliable transport
        Err(self.discard_message(message))
    }

    /// 9.1.4 Receiving a Response
    fn process_response(
        &mut self,
        raw_buffer: &[u8],
        msg: &StunMessage,
    ) -> Result<(), AuthValidationError> {
        let mut integrity = None;
        let mut integrity_sha256 = None;

        for attr in msg.attributes() {
            if attr.is_message_integrity() {
                integrity = Some(attr);
            }
            if attr.is_message_integrity_sha256() {
                integrity_sha256 = Some(attr);
            }
            if integrity.is_some() && integrity_sha256.is_some() {
                // Only one integrity attribute must be set
                // TODO: Add logging
                println!("Both integrity attributes are set");
                return Err(AuthValidationError::Discarded);
            }
        }

        match &self.integrity {
            Some(val) => {
                let attribute = match val {
                    Integrity::MessageIntegrity => integrity,
                    Integrity::MessageIntegritySha256 => integrity_sha256,
                };

                self.compute_message_integrity(attribute, raw_buffer, msg)
            }
            None => {
                let integrity = integrity.or(integrity_sha256);
                self.compute_message_integrity(integrity, raw_buffer, msg)?;
                if let Some(attr) = integrity {
                    if attr.is_message_integrity() {
                        self.integrity = Some(Integrity::MessageIntegrity);
                    } else {
                        self.integrity = Some(Integrity::MessageIntegritySha256);
                    }
                }
                Ok(())
            }
        }
    }

    pub fn recv_message(
        &mut self,
        raw_buffer: &[u8],
        msg: &StunMessage,
    ) -> Result<(), AuthValidationError> {
        match msg.class() {
            MessageClass::Request | MessageClass::Indication => Ok(()),
            MessageClass::SuccessResponse | MessageClass::ErrorResponse => {
                self.process_response(raw_buffer, msg)
            }
        }
    }

    /// 9.1.2.  Forming a Request or Indication
    /// For a request or indication message, the agent MUST include the
    /// USERNAME, MESSAGE-INTEGRITY-SHA256, and MESSAGE-INTEGRITY attributes
    /// in the message unless the agent knows from an external mechanism
    /// which message integrity algorithm is supported by both agents.  In
    /// this case, either MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 MUST
    /// be included in addition to USERNAME.  The HMAC for the MESSAGE-
    /// INTEGRITY attribute is computed as described in Section 14.5, and the
    /// HMAC for the MESSAGE-INTEGRITY-SHA256 attributes is computed as
    /// described in Section 14.6.  Note that the password is never included
    /// in the request or indication.
    fn prepare_request_or_indication(&self, attributes: &mut StunAttributes) {
        // Add username attribute
        attributes.add(self.user_name.clone());

        if let Some(integrity) = &self.integrity {
            // Add integrity attribute
            match integrity {
                Integrity::MessageIntegrity => {
                    attributes.add(MessageIntegrity::new(self.key.clone()))
                }
                Integrity::MessageIntegritySha256 => {
                    attributes.add(MessageIntegritySha256::new(self.key.clone()))
                }
            }
        } else {
            // Add MESSAGE-INTEGRITY and MESSAGE-INTEGRITY-SHA256 attributes
            attributes.add(MessageIntegrity::new(self.key.clone()));
            attributes.add(MessageIntegritySha256::new(self.key.clone()));
        }
    }

    pub fn add_attributes(&self, attributes: &mut StunAttributes) {
        self.prepare_request_or_indication(attributes);
    }

    pub fn signal_protection_violated_on_timeout(
        &mut self,
        transaction_id: &TransactionId,
    ) -> bool {
        self.discarded.remove(transaction_id)
    }
}

fn validate_message_integrity(integrity: &StunAttribute, key: &HMACKey, raw_buffer: &[u8]) -> bool {
    if let Ok(attr) = integrity.as_message_integrity() {
        let Some(input) = get_input_text::<MessageIntegrity>(raw_buffer) else {
            return false;
        };
        attr.validate(&input, key)
    } else if let Ok(attr) = integrity.as_message_integrity_sha256() {
        let Some(input) = get_input_text::<MessageIntegritySha256>(raw_buffer) else {
            return false;
        };
        attr.validate(&input, key)
    } else {
        false
    }
}

#[cfg(test)]
mod short_term_auth_tests {
    use super::*;
    use stun_rs::attributes::stun::Software;
    use stun_rs::methods::BINDING;
    use stun_rs::{
        MessageDecoderBuilder, MessageEncoderBuilder, StunAttributeType, StunError,
        StunMessageBuilder,
    };

    const USERNAME: &str = "test-username";
    const PASSWORD: &str = "test-password";
    const SOFTWARE: &str = "STUN test client";

    fn create_response_message(buffer: &mut [u8], integrity: Integrity) -> usize {
        let software = Software::new(SOFTWARE).expect("Could not create Software attribute");
        let user_name = UserName::try_from(USERNAME).expect("Can not create USERNAME attribute");
        let key = HMACKey::new_short_term(PASSWORD).expect("Could not create HMACKey");
        let integrity: StunAttribute = match integrity {
            Integrity::MessageIntegrity => MessageIntegrity::new(key).into(),
            Integrity::MessageIntegritySha256 => MessageIntegritySha256::new(key).into(),
        };

        let enc_msg = StunMessageBuilder::new(BINDING, MessageClass::SuccessResponse)
            .with_attribute(software)
            .with_attribute(user_name)
            .with_attribute(integrity)
            .build();

        let encoder = MessageEncoderBuilder::default().build();
        encoder
            .encode(buffer, &enc_msg)
            .expect("Failed to encode message")
    }

    fn integrity_tests<A>()
    where
        A: StunAttributeType,
    {
        let integrity = if A::get_type() == MessageIntegrity::get_type() {
            Integrity::MessageIntegrity
        } else if A::get_type() == MessageIntegritySha256::get_type() {
            Integrity::MessageIntegritySha256
        } else {
            panic!("Invalid integrity attribute type {}", A::get_type());
        };

        let key = HMACKey::new_short_term(PASSWORD).expect("Could not create HMACKey");
        let mut buffer: [u8; 150] = [0x00; 150];
        let _ = create_response_message(&mut buffer, integrity);

        let decoder = MessageDecoderBuilder::default().build();
        let (msg, _) = decoder.decode(&buffer).expect("Failed to decode message");

        // Check that software is not an integrity attribute
        let attr = msg
            .get::<Software>()
            .ok_or("Software attribute not found")
            .expect("Failed to get Software attribute");
        assert!(!validate_message_integrity(attr, &key, &buffer));

        // MessageIntegrity is valid
        let attr = msg
            .get::<A>()
            .ok_or("integrity attribute not found")
            .expect("Failed to get integrity attribute");
        assert!(validate_message_integrity(attr, &key, &buffer));

        // Change a value will make validation fail (change a value in the transactio id)
        buffer[15] = 0xff;
        assert!(!validate_message_integrity(attr, &key, &buffer));
    }
    #[test]
    fn test_integrity_validation() {
        integrity_tests::<MessageIntegrity>();
        integrity_tests::<MessageIntegritySha256>();
    }

    fn check_attributes(integrity: Option<Integrity>, attributes: &[StunAttribute]) {
        let mut iter = attributes.iter();

        let attr = iter.next().expect("Expected attribute UserName");
        assert!(attr.is_user_name());

        match integrity {
            Some(Integrity::MessageIntegrity) => {
                let attr = iter.next().expect("Expected attribute MessageIntegrity");
                assert!(attr.is_message_integrity());
                assert!(iter.next().is_none());
            }
            Some(Integrity::MessageIntegritySha256) => {
                let attr = iter
                    .next()
                    .expect("Expected attribute MessageIntegritySha256");
                assert!(attr.is_message_integrity_sha256());
                assert!(iter.next().is_none());
            }
            None => {
                let attr = iter.next().expect("Expected attribute MessageIntegrity");
                assert!(attr.is_message_integrity());

                let attr = iter
                    .next()
                    .expect("Expected attribute MessageIntegritySha256");
                assert!(attr.is_message_integrity_sha256());
                assert!(iter.next().is_none());
            }
        }
    }

    fn new_short_term_auth_client(
        integrity: Option<Integrity>,
        is_reliable: bool,
    ) -> Result<ShortTermAuthClient, StunError> {
        Ok(ShortTermAuthClient::new(
            UserName::new(USERNAME)?,
            HMACKey::new_short_term(PASSWORD)?,
            integrity,
            is_reliable,
        ))
    }

    #[test]
    fn test_send_request() {
        let integrity = None;
        let client = new_short_term_auth_client(integrity, false)
            .expect("Failed to create ShortTermAuthClient");
        let mut attributes = StunAttributes::default();
        client.add_attributes(&mut attributes);
        let attrs: Vec<StunAttribute> = attributes.into();
        check_attributes(integrity, &attrs);

        let integrity = Some(Integrity::MessageIntegrity);
        let client = new_short_term_auth_client(integrity, false)
            .expect("Failed to create ShortTermAuthClient");
        let mut attributes = StunAttributes::default();
        client.add_attributes(&mut attributes);
        let attrs: Vec<StunAttribute> = attributes.into();
        check_attributes(integrity, &attrs);

        let integrity = Some(Integrity::MessageIntegritySha256);
        let client = new_short_term_auth_client(integrity, false)
            .expect("Failed to create ShortTermAuthClient");
        let mut attributes = StunAttributes::default();
        client.add_attributes(&mut attributes);
        let attrs: Vec<StunAttribute> = attributes.into();
        check_attributes(integrity, &attrs);
    }

    #[test]
    fn test_recv_response_message_integrity() {
        let mut buffer: [u8; 150] = [0x00; 150];
        let _ = create_response_message(&mut buffer, Integrity::MessageIntegrity);

        let decoder = MessageDecoderBuilder::default().build();
        let (msg, size) = decoder.decode(&buffer).expect("Failed to decode message");

        let mut client =
            new_short_term_auth_client(None, false).expect("Failed to create ShortTermAuthClient");
        client
            .recv_message(&buffer[..=size], &msg)
            .expect("Failed to process response");

        // This message should not be timeout out as it was successfully authenticated
        assert!(!client.signal_protection_violated_on_timeout(msg.transaction_id()));

        // Processing the message must make the client pick the MessageIntegrity mechanism
        let mut attributes = StunAttributes::default();
        client.add_attributes(&mut attributes);
        let attrs: Vec<StunAttribute> = attributes.into();
        check_attributes(Some(Integrity::MessageIntegrity), &attrs);

        // Change the integrity attribute to MessageIntegritySha256 in the next
        // response must make the client drop the message
        let _ = create_response_message(&mut buffer, Integrity::MessageIntegritySha256);
        let decoder = MessageDecoderBuilder::default().build();
        let (msg, size) = decoder.decode(&buffer).expect("Failed to decode message");
        assert_eq!(
            Err(AuthValidationError::Discarded),
            client.recv_message(&buffer[..=size], &msg)
        );

        // A timout on this not authenticated message must fire a ProtectionViolated error
        assert!(client.signal_protection_violated_on_timeout(msg.transaction_id()));
    }

    #[test]
    fn test_recv_response_message_integrity_sha256() {
        let mut buffer: [u8; 150] = [0x00; 150];
        let _ = create_response_message(&mut buffer, Integrity::MessageIntegritySha256);

        let decoder = MessageDecoderBuilder::default().build();
        let (msg, size) = decoder.decode(&buffer).expect("Failed to decode message");

        let mut client =
            new_short_term_auth_client(None, false).expect("Failed to create ShortTermAuthClient");
        client
            .recv_message(&buffer[..=size], &msg)
            .expect("Failed to process response");

        // This message should not be timeout out as it was successfully authenticated
        assert!(!client.signal_protection_violated_on_timeout(msg.transaction_id()));

        // Processing the message must make the client pick the MessageIntegritySha256 mechanism
        let mut attributes = StunAttributes::default();
        client.add_attributes(&mut attributes);
        let attrs: Vec<StunAttribute> = attributes.into();
        check_attributes(Some(Integrity::MessageIntegritySha256), &attrs);

        // Change the integrity attribute to MessageIntegrity in the next
        // response must make the client drop the message
        let _ = create_response_message(&mut buffer, Integrity::MessageIntegrity);
        let decoder = MessageDecoderBuilder::default().build();
        let (msg, size) = decoder.decode(&buffer).expect("Failed to decode message");
        assert_eq!(
            Err(AuthValidationError::Discarded),
            client.recv_message(&buffer[..=size], &msg)
        );

        // A timout on this not authenticated message must fire a ProtectionViolated error
        assert!(client.signal_protection_violated_on_timeout(msg.transaction_id()));
    }

    #[test]
    fn test_recv_response_message_integrity_both() {
        let software =
            Software::new("STUN test client").expect("Could not create Software attribute");
        let user_name = UserName::try_from(USERNAME).expect("Can not create USERNAME attribute");
        let key = HMACKey::new_short_term(PASSWORD).expect("Could not create HMACKey");
        let integrity = MessageIntegrity::new(key.clone());
        let integrity_sha256 = MessageIntegritySha256::new(key);

        let msg = StunMessageBuilder::new(BINDING, MessageClass::SuccessResponse)
            .with_attribute(software)
            .with_attribute(user_name)
            .with_attribute(integrity)
            .with_attribute(integrity_sha256)
            .build();

        let encoder = MessageEncoderBuilder::default().build();
        let mut buffer: [u8; 150] = [0x00; 150];
        let size = encoder
            .encode(&mut buffer, &msg)
            .expect("Failed to encode message");

        // Responses can not have integrity and integrity_sha256 attributes at the same time
        let mut client =
            new_short_term_auth_client(None, false).expect("Failed to create ShortTermAuthClient");
        assert_eq!(
            Err(AuthValidationError::Discarded),
            client.recv_message(&buffer[..=size], &msg)
        );

        // Protection violated error should not be signaled if both integrity attributes were present
        assert!(!client.signal_protection_violated_on_timeout(msg.transaction_id()));
    }

    #[test]
    fn test_recv_response_message_integrity_miss_both() {
        let software =
            Software::new("STUN test client").expect("Could not create Software attribute");
        let user_name = UserName::try_from(USERNAME).expect("Can not create USERNAME attribute");

        let msg = StunMessageBuilder::new(BINDING, MessageClass::SuccessResponse)
            .with_attribute(software)
            .with_attribute(user_name)
            .build();

        let encoder = MessageEncoderBuilder::default().build();
        let mut buffer: [u8; 150] = [0x00; 150];
        let size = encoder
            .encode(&mut buffer, &msg)
            .expect("Failed to encode message");

        // Responses have neither integrity nor integrity_sha256 attributes
        let mut client =
            new_short_term_auth_client(None, false).expect("Failed to create ShortTermAuthClient");
        assert_eq!(
            Err(AuthValidationError::Discarded),
            client.recv_message(&buffer[..=size], &msg)
        );

        // A timout on this not authenticated message must fire a ProtectionViolated error
        assert!(client.signal_protection_violated_on_timeout(msg.transaction_id()));
    }

    #[test]
    fn test_recv_response_on_reliable() {
        let software =
            Software::new("STUN test client").expect("Could not create Software attribute");
        let user_name = UserName::try_from(USERNAME).expect("Can not create USERNAME attribute");

        let msg = StunMessageBuilder::new(BINDING, MessageClass::SuccessResponse)
            .with_attribute(software)
            .with_attribute(user_name)
            .build();

        let encoder = MessageEncoderBuilder::default().build();
        let mut buffer: [u8; 150] = [0x00; 150];
        let size = encoder
            .encode(&mut buffer, &msg)
            .expect("Failed to encode message");

        // Responses have neither integrity nor integrity_sha256 attributes
        let mut client =
            new_short_term_auth_client(None, true).expect("Failed to create ShortTermAuthClient");
        assert_eq!(
            Err(AuthValidationError::ProtectionViolated),
            client.recv_message(&buffer[..=size], &msg)
        );

        // A timout on a reliable channel must not fire a ProtectionViolated error
        assert!(!client.signal_protection_violated_on_timeout(msg.transaction_id()));
    }
}
